/* FILE: fixedzeeman.h            -*-Mode: c++-*-
 *
 * Fixed (in time) Zeeman energy/field, derived from Oxs_Energy class.
 *
 */

#ifndef _GPU_UNIAXIALANISOTROPY_NEW
#define _GPU_UNIAXIALANISOTROPY_NEW

#ifndef BLK_SIZE
#define BLK_SIZE 128
#endif

#define GPU_CPU_TRANS

#include "oc.h"
#include "director.h"
#include "threevector.h"
#include "GPU_energy.h"
#include "simstate.h"
#include "mesh.h"
#include "meshvalue.h"
#include "vectorfield.h"

#include "GPU_helper.h"
/* End includes */

class GPU_UniaxialAnisotropy_New
  : public Oxs_GPU_Energy, public Oxs_EnergyPreconditionerSupport  {
private:

  enum AnisotropyCoefType {
    ANIS_UNKNOWN, K1_TYPE, Ha_TYPE
  } aniscoeftype;
  
  Oxs_OwnedPointer<Oxs_ScalarField> K1_init;
  Oxs_OwnedPointer<Oxs_ScalarField> Ha_init;
  Oxs_OwnedPointer<Oxs_VectorField> axis_init;
  mutable Oxs_ThreadControl thread_control;
  mutable Oxs_MeshValue<OC_REAL8m> K1;
  mutable Oxs_MeshValue<OC_REAL8m> Ha;
  mutable Oxs_MeshValue<ThreeVector> axis;
  /// K1, Ha, and axis are cached values filled by corresponding
  /// *_init members when a change in mesh is detected.

  // It is not uncommon for the anisotropy to be specified by uniform
  // fields.  In this case, memory traffic can be significantly
  // reduced, which may be helpful in parallelized code.  The
  // variables uniform_K1/Ha/axis_value are valid iff the corresponding
  // boolean is true.
  OC_BOOL K1_is_uniform;
  OC_BOOL Ha_is_uniform;
  OC_BOOL axis_is_uniform;
  OC_REAL8m uniform_K1_value;
  OC_REAL8m uniform_Ha_value;
  ThreeVector uniform_axis_value;
    
  enum IntegrationMethod {
    UNKNOWN_INTEG, RECT_INTEG, QUAD_INTEG
  } integration_method;
  /// Integration formulation to use.  "unknown" is invalid; it
  /// is defined for error detection.
  
  OC_BOOL has_multscript;
  OC_UINT4m number_of_stages;
  
  // Variables to track and store multiplier value for each simulation
  // state.  This data is computed once per state by the main thread,
  // and shared with all the children.
  mutable OC_UINT4m mult_state_id;
  mutable OC_REAL8m mult;
  mutable OC_REAL8m dmult; // Partial derivative of multiplier wrt t
  
  mutable OC_UINT4m mesh_id;
  
  void GetMultiplier(const Oxs_SimState& state,
     OC_REAL8m& mult,
     OC_REAL8m& dmult) const {
     
    if(!has_multscript) {
      mult = 1.0;
      dmult = 0.0;
    } else {
      throw Oxs_ExtError(this, "multiscript is not supported in GPU library yet");
    }
  }

#if REPORT_TIME
  mutable Nb_StopWatch Anistime;
#endif
  mutable int maxGridSize;
  mutable FD_TYPE maxTotalThreads;
  
#ifdef GPU_DEBUG
  mutable std::ofstream location;
#endif

  mutable int _dev_num;
  mutable dim3 block_size;
  mutable dim3 grid_size;
  mutable uint3 flag_uniform;
  mutable FD_TYPE *dev_MValue;
  mutable FD_TYPE *dev_Ms;
  mutable FD_TYPE *dev_inv_Ms;
  mutable FD_TYPE *dev_Energy;
  mutable FD_TYPE *dev_Field;
  mutable FD_TYPE *dev_Torque;
  mutable FD_TYPE *dev_energy_loc;
  mutable FD_TYPE *dev_field_loc;
  mutable FD_TYPE* dev_volume;
  mutable FD_TYPE *dev_tmp;
  mutable FD_TYPE *dev_K1;
  mutable FD_TYPE *dev_Ha;
  mutable FD_TYPE *dev_axis;
  mutable FD_TYPE3 dev_uniform_axis_value;
  mutable FD_TYPE dev_uniform_K1_value;
  mutable FD_TYPE dev_uniform_Ha_value;
  mutable FD_TYPE dev_mult;
  mutable FD_TYPE *tmp_energy;
  mutable FD_TYPE *tmp_field;
  void AllocCPUMemory(const OC_INDEX &size) const;
  void AllocGPUMemory(const OC_INDEX &size, DEVSTRUCT& dev_struct) const;
  void ReleaseGPUMemory() const;
  void ReleaseCPUMemory() const;
  
  void InitGPU( const OC_INDEX &size, DEVSTRUCT& dev_struct) const;
  void ReInitGPU(const DEVSTRUCT& dev_struct) const;
  
protected:
  virtual void GetEnergy(const Oxs_SimState& state,
			 Oxs_EnergyData& oed) const{};
  virtual void GPU_GetEnergy(const Oxs_SimState& state,
			 Oxs_EnergyData& oed, DEVSTRUCT& dev_struct,
			 unsigned int flag_outputH, unsigned int flag_outputE,
			 unsigned int flag_outputSumE, const OC_BOOL &flag_accum) const;
public:
  virtual const char* ClassName() const; // ClassName() is
  /// automatically generated by the OXS_EXT_REGISTER macro.
  GPU_UniaxialAnisotropy_New(const char* name,  // Child instance id
		  Oxs_Director* newdtr, // App director
		  const char* argstr);  // MIF input block parameters

  virtual ~GPU_UniaxialAnisotropy_New();// {ReleaseGPUMemory();}
  virtual OC_BOOL Init();

  // Optional interface for conjugate-gradient evolver.
  // For details on this code, see NOTES VI, 21-July-2011, pp 10-11.
  virtual OC_INT4m IncrementPreconditioner(
      PreconditionerData& pcd) {
    throw Oxs_ExtError(this, "preconditioner is not supported by GPU libraries yet");
  }
};


#endif // _GPU_FIXEDZEEMAN_NEW
